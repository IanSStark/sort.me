# =========================
# sort.me — application configuration
# =========================

# --------
# MOTION (MPCNC running Marlin)
# --------
motion:
  enabled: true
  baud: 250000
  # any (or none) of these:
  by_id_contains: "usb-Marlin"   # substring of /dev/serial/by-id/*
  vid: "0483"                    # example: STMicroelectronics
  pid: "5740"
  port: "/dev/ttyACM0"           # fallback
          # app starts with motion disabled; enable via API/UI
  read_timeout_s: 2.0
  write_timeout_s: 2.0
  connect_timeout_s: 6.0

  # Reset behavior on connect (depends on your USB–MCU wiring)
  reset_on_connect: true
  startup_drain_s: 2.0        # give Marlin time to print startup banner and clear it

  # Firmware response tokens (Marlin)
  ok_tokens: ["ok"]
  error_tokens: ["error", "Error:"]
  busy_tokens: ["busy:", "wait"]

  # Default movement & safety (tweak for your machine)
  absolute_mode: true         # G90 by default
  safe_z_mm: 5.0              # Z lift for travels to avoid collisions (set to 0 if not needed)
  travel_feed_xy: 1800        # mm/min default traverse feedrate in XY
  travel_feed_z: 600          # mm/min default Z feedrate

  # Homing behavior (requires endstops if true)
  home_on_start: false
  home_axes: "XY"             # options: "X", "Y", "Z", "XY", "XYZ" (honored only if homing is supported)

  # Standby position after a placement (set null to skip)
  standby_pos:
    x: 0.0
    y: 0.0
    z: 10.0

  # Motion test square defaults (used by /motion/test-square)
  test_square:
    size_mm: 20.0
    feed_xy: 1200

# --------
# GRID / BINS
# Converts a slot index (e.g., 1..N) or letter ('A'..'Z') into XY coordinates
# --------
grid:
  rows: 1
  cols: 6
  origin_xy_mm: [10.0, 10.0]   # center of (row=0,col=0)
  pitch_xy_mm:  [35.0, 0.0]    # 35 mm step in X, 0 in Y (single row)
  row_major: true

  # Optional fine trims per zone key (mm)
  overrides: { }

  # Define named zones (0-based row/col)
  zones:
    - key: FEED
      type: feeder
      row: 0
      col: 0
    - key: S1
      type: sort
      row: 0
      col: 1
    - key: S2
      type: sort
      row: 0
      col: 2
    - key: S3
      type: sort
      row: 0
      col: 3
    - key: S4
      type: sort
      row: 0
      col: 4
    - key: S5
      type: sort
      row: 0
      col: 5

  # Optional: map letters to zone keys for alphabetizing (enable when ready)
  alpha_map:
    A: S1
    B: S1
    C: S1
    D: S2
    E: S2
    F: S2
    G: S3
    H: S3
    I: S3
    J: S4
    K: S4
    L: S4
    M: S5
    N: S5
    O: S5
    P: S5
    Q: S5
    R: S5
    S: S5
    T: S5
    U: S5
    V: S5
    W: S5
    X: S5
    Y: S5
    Z: S5

# --------
# PLUNGER / ACTUATOR (optional)
# Use if you have a Z-based drop, solenoid, servo, or an auxiliary axis
# --------
plunger:
  # Approach parameters (used if you perform a drop sequence at a bin)
  use_z_drop: true            # if false, skip Z actuation entirely
  approach_z_mm: 5.0          # Z height before drop
  drop_z_mm: 0.5              # how far to move down to release a card
  retract_z_mm: 8.0           # retract to this Z after drop
  feed_z_approach: 600        # mm/min
  feed_z_drop: 300            # mm/min
  feed_z_retract: 600         # mm/min
  dwell_after_drop_s: 0.15    # pause to ensure clean release

  # If you use a GPIO or servo instead of Z, define those here (app logic may need to call this)
  gpio:
    enabled: false
    pin: 17                   # BCM numbering
    active_high: true
    pulse_ms: 120

  servo:
    enabled: false
    channel: 0                # depends on your servo driver
    angle_open: 45
    angle_closed: 0
    pulse_ms: 250

# --------
# CAMERA
# --------
camera:
  device: null                # e.g., 0 for default webcam; null for auto-discovery if supported
  backend: null               # e.g., "opencv", "picamera2"; null lets app decide
  resolution: [1280, 720]
  preview_fps: 10
  rotate_deg: 0               # 0|90|180|270
  flip_horizontal: false
  flip_vertical: false
  captures_dir: "captures"    # where snapshots are saved

# --------
# OCR
# --------
ocr:
  engine: "tesseract"         # or another engine supported by your code
  lang: "eng"
  psm: 6                      # Tesseract page segmentation mode
  oem: 1                      # Tesseract engine mode
  whitelist: null             # e.g., "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
  min_accept_confidence: 75   # reject if mean conf below this threshold
  top_priority_fraction: 0.35 # prefer top line fraction of the image (card titles often at top)
  top_bias_bonus: 10.0        # bias score added to lines in the top region
  min_line_chars: 3
  # Optional region-of-interest (cropping) as fractions of the full frame [0..1]
  # Useful to restrict OCR to where titles usually appear.
  roi_fraction:
    x0: 0.05
    y0: 0.05
    x1: 0.95
    y1: 0.35

# --------
# PIPELINE / SORT LOGIC
# --------
pipeline:
  # If true, automatically perform: capture → OCR → decide bin → move → drop → standby
  auto_place_after_ocr: false

  # If OCR fails or confidence too low
  on_ocr_fail: "skip"         # "skip" | "park" | "retry"
  max_retries: 1
  retry_dwell_s: 0.5

  # Letter extraction rules
  # - "first_alpha": first alphabetical character from OCR result
  # - "first_word_initial": take initial of first token (robust for titles)
  letter_rule: "first_word_initial"

# --------
# SERVER / UI
# --------
server:
  host: "0.0.0.0"
  port: 8000
  templates_dir: "templates"
  static_dir: "static"

# --------
# CORS
# --------
cors:
  allow_origins: ["*"]
  allow_methods: ["*"]
  allow_headers: ["*"]
  allow_credentials: false

# --------
# LOGGING
# --------
logging:
  level: "INFO"               # DEBUG | INFO | WARNING | ERROR
  log_to_file: false
  file_path: "sortme.log"
  max_bytes: 10485760         # 10 MB
  backup_count: 5

# --------
# ASSIGNMENT / MISC (reserved for UI helpers or future use)
# --------
assignment: { }
